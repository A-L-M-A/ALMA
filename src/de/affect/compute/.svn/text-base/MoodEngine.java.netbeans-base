/* * MoodEngine.java * * Copyright (c) 2004, 2005, 2006, 2007, 2008, Patrick Gebhard, DFKI GmbH * * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * *   - Redistributions of source code must retain the above copyright *     notice, this list of conditions and the following disclaimer. * *   - Redistributions in binary form must reproduce the above copyright *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution. * *   - Neither the name of the DFKI GmbH nor the names of its contributors *     may be used to endorse or promote products derived from this software *     without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */package de.affect.compute;import java.util.Iterator;import java.util.logging.Logger;import static java.lang.Math.abs;import static java.lang.Math.random;import static java.lang.Math.signum;import de.affect.emotion.Emotion;import de.affect.emotion.EmotionVector;import de.affect.mood.Mood;import de.affect.personality.Personality;import de.affect.emotion.EmotionType;import de.affect.emotion.EmotionPADCentroid;import de.affect.emotion.PADEmotion;import static de.affect.emotion.EmotionsPADRelation.getEmotionPADMapping;import jama.Matrix;/** * The <code>MoodEngine</code> class is used to compute the current mood of a * character based on it's personality and current active emotions. * * @author Patrick Gebhard * * @version 1.0 */public class MoodEngine {  private Personality fPersonality = null;  private Mood fDefaultMood = null;  private Mood fCurrentMoodTendency = null;  private EmotionPADCentroid fEmotionsCenter = null;  private Logger log = null;  private boolean fNeurotismMoodChanges = false;  private int fNeurotismMoodChangeTime = 1;  private int fRelativeMoodOctant = 0;  private int fLastRelativeMoodOctant = 0;  private static double fLowestValue = 0.0001d;  private static long fOverallMoodReturnPeriods = 0; // ten minutes  private long fOverallMoodReturnCnt = 0;  private final static int sMOODSTEPS = 100; //better 300  private final static double sDEFAULTMOODIMPACT = 0.25d;  private final static int sNeurotismMoodChangeMaxTime = 8;  public MoodEngine(Personality personality, boolean neuroticMoodChanges, Mood defaultMood, double compPeriod) {    fPersonality = personality;    fDefaultMood = defaultMood;    fEmotionsCenter = new EmotionPADCentroid();    fNeurotismMoodChanges = neuroticMoodChanges;    // fNeurotismMoodChangeTime is reciproc to the neurotism value.    // The higher neurotsim is, the the lowe fNeurotismMoodChangeTime.    fNeurotismMoodChangeTime = 1 + sNeurotismMoodChangeMaxTime -            (new Double((fPersonality.getNeurotism() + 1.0d)).intValue() * sNeurotismMoodChangeMaxTime / 2);    fOverallMoodReturnPeriods = (new Double(60000 / compPeriod)).intValue();    log = Logger.global;  }  private Mood moveMoodLinear(Mood currentMood, double strength,          double pValue, double aValue, double dValue) {    Mood resultMood = null;    double currentPleasure = currentMood.getPleasure();    double currentArousal = currentMood.getArousal();    double currentDominance = currentMood.getDominance();    // get the subcube boundaries if fEmotionCenter is in the current mood octant cube    double newPValue = currentPleasure + (pValue / sMOODSTEPS * strength);    newPValue = checkValue(newPValue);    double newAValue = currentArousal + (aValue / sMOODSTEPS * strength);    newAValue = checkValue(newAValue);    double newDValue = currentDominance + (dValue / sMOODSTEPS * strength);    newDValue = checkValue(newDValue);    fCurrentMoodTendency = new Mood(checkValue(currentPleasure + pValue),            checkValue(currentArousal + aValue),            checkValue(currentDominance + dValue));    if (isEmotionCenterInCurrentMoodOctantCube(currentMood)) {      //debug log.info("EmotionCenter is in mood cube - mood will not leave cube!");      double pleasureEnd = signum(currentPleasure);      newPValue = (pleasureEnd < 0.0d) ? (newPValue > 0.0d) ? 0.0d : newPValue : (newPValue < 0.0d) ? 0.0d : newPValue;      double arousalEnd = signum(currentArousal);      newAValue = (arousalEnd < 0.0d) ? (newAValue > 0.0d) ? 0.0d : newAValue : (newAValue < 0.0d) ? 0.0d : newAValue;      double dominanceEnd = signum(currentDominance);      newDValue = (dominanceEnd < 0.0d) ? (newDValue > 0.0d) ? 0.0d : newDValue : (newDValue < 0.0d) ? 0.0d : newDValue;    }    resultMood = new Mood(newPValue, newAValue, newDValue);    return resultMood;  }  private Mood randomMoodChange(Mood currentMood, double strength,          double pValue, double aValue, double dValue) {    // to which octant the current mood should move	    fRelativeMoodOctant = (new Double(random() * 8.0d)).intValue();    double newPValue = currentMood.getPleasure();    double newAValue = currentMood.getArousal();    double newDValue = currentMood.getDominance();//     log.info("relative mood octant " + fRelativeMoodOctant + //  	     " P:" + ((fRelativeMoodOctant >> 2) % 2) +//  	     " A:" + ((fRelativeMoodOctant >> 1) % 2) +//  	     " D:" + ((fRelativeMoodOctant >> 0) % 2));    // allow only random values that are not opposite to the current mood     // move direction    newPValue = ((((fRelativeMoodOctant >> 2) % 2) > 0) && (signum(pValue) >= 0)) ? newPValue + strength : newPValue - strength;    newPValue = checkValue(newPValue);    newAValue = ((((fRelativeMoodOctant >> 1) % 2) > 0) && (signum(aValue) >= 0)) ? newAValue + strength : newAValue - strength;    newAValue = checkValue(newAValue);    newDValue = ((((fRelativeMoodOctant >> 0) % 2) > 0) && (signum(dValue) >= 0)) ? newDValue + strength : newDValue - strength;    newDValue = checkValue(newDValue);    return new Mood(newPValue, newAValue, newDValue);  }  private double checkValue(double value) {    double result = value;    result = (result > 1.0d) ? 1.0d : result;    result = (result < -1.0d) ? -1.0d : result;    return result;  }  private Mood getPADPlanePoint(EmotionPADCentroid eCenter, Mood currentMood) {    Mood result = new Mood(0., 0., 0.);    double curMoodPValue = currentMood.getPleasure();    double curMoodAValue = currentMood.getArousal();    double curMoodDValue = currentMood.getDominance();    double pMoodToECenter = (eCenter.getPValue() - curMoodPValue);    double aMoodToECenter = (eCenter.getAValue() - curMoodAValue);    double dMoodToECenter = (eCenter.getDValue() - curMoodDValue);    //log.info("pMoodToECenter " + pMoodToECenter);    //log.info("aMoodToECenter " + aMoodToECenter);    //log.info("dMoodToECenter " + dMoodToECenter);    if ((abs(pMoodToECenter) <= fLowestValue) &&            (abs(aMoodToECenter) <= fLowestValue) &&            (abs(dMoodToECenter) <= fLowestValue)) {      return null;    }    double[][][] inputVals = {{{pMoodToECenter, -1., 0.}, {aMoodToECenter, 0., 0.}, {dMoodToECenter, 0., -1.}},      {{pMoodToECenter, -1., 0.}, {aMoodToECenter, 0., 0.}, {dMoodToECenter, 0., -1.}},      {{pMoodToECenter, 0., 0.}, {aMoodToECenter, -1., 0.}, {dMoodToECenter, 0., -1.}},      {{pMoodToECenter, 0., 0.}, {aMoodToECenter, -1., 0.}, {dMoodToECenter, 0., -1.}},      {{pMoodToECenter, -1., 0.}, {aMoodToECenter, 0., -1.}, {dMoodToECenter, 0., 0.}},      {{pMoodToECenter, -1., 0.}, {aMoodToECenter, 0., -1.}, {dMoodToECenter, 0., 0.}}    };    double[][][] bVals = {{{0.}, {-1. - curMoodAValue}, {0.}},      {{0.}, {1. - curMoodAValue}, {0.}},      {{-1. - curMoodPValue}, {0.}, {0.}},      {{1. - curMoodPValue}, {0.}, {0.}},      {{0.}, {0.}, {-1. - curMoodDValue}},      {{0.}, {0.}, {1. - curMoodDValue}}    };    for (int i = 0; i < 6; i++) {      // check if end point is in neagtive pleasure plane      Matrix A = new Matrix(inputVals[i]);      Matrix b = new Matrix(bVals[i]);      double fac = 0.0d;      if (A.det() != 0.0d) {        Matrix x = A.solve(b);        fac = x.get(0, 0);      } else {        // special case, if only one part differs from zero. Than the current        // mood should move according to that part.        return new Mood(signum(pMoodToECenter), signum(aMoodToECenter), signum(dMoodToECenter));      }      double PPoint = curMoodPValue + fac * pMoodToECenter;      double APoint = curMoodAValue + fac * aMoodToECenter;      double DPoint = curMoodDValue + fac * dMoodToECenter;      if ((PPoint <= 1.0d) && (PPoint >= -1.0d) &&              (APoint <= 1.0d) && (APoint >= -1.0d) &&              (DPoint <= 1.0d) && (DPoint >= -1.0d)) {        result = (fac > 0.0d) ? new Mood(PPoint, APoint, DPoint) : new Mood(-PPoint, -APoint, -DPoint);      }    }    return result;  }  public synchronized EmotionPADCentroid getEmotionsCenter() {    return fEmotionsCenter;  }  private boolean isEmotionCenterInCurrentMoodOctantCube(Mood currentMood) {    boolean isInCurrentMoodOctantCube = false;    double pleasureEnd = signum(currentMood.getPleasure());    double arousalEnd = signum(currentMood.getArousal());    double dominanceEnd = signum(currentMood.getDominance());    boolean isInPleasurePart = false;    if ((pleasureEnd > 0.0d) && (fEmotionsCenter.getPValue() > 0.0d)) {      isInPleasurePart = true;    }    if ((pleasureEnd < 0.0d) && (fEmotionsCenter.getPValue() < 0.0d)) {      isInPleasurePart = true;    }    boolean isInArousalPart = false;    if ((arousalEnd > 0.0d) && (fEmotionsCenter.getAValue() > 0.0d)) {      isInArousalPart = true;    }    if ((arousalEnd < 0.0d) && (fEmotionsCenter.getAValue() < 0.0d)) {      isInArousalPart = true;    }    boolean isInDominancePart = false;    if ((dominanceEnd > 0.0d) && (fEmotionsCenter.getDValue() > 0.0d)) {      isInDominancePart = true;    }    if ((dominanceEnd < 0.0d) && (fEmotionsCenter.getDValue() < 0.0d)) {      isInDominancePart = true;    }    if (isInPleasurePart && isInArousalPart && isInDominancePart) {      isInCurrentMoodOctantCube = true;    }    return isInCurrentMoodOctantCube;  }  /**   * <code>isMoodAtEmotionsCenter</code> checks is the current mood is at the   * emotion(s) center postion.   *   * @param currentMood the current mood that will be checked if it is at the    *                    emotion(s) center position.   *   * @return boolean true if the current mood is near (&lt; 0.004d) the    *                 emotion(s) center postion, false otherwise   */  private boolean isMoodAtEmotionsCenter(Mood currentMood) {    boolean isAtEmotionCenter = false;    double pRange = (fEmotionsCenter.getPValue() - currentMood.getPleasure());    double aRange = (fEmotionsCenter.getAValue() - currentMood.getArousal());    double dRange = (fEmotionsCenter.getDValue() - currentMood.getDominance());    if ((abs(pRange) < 0.001d) && (abs(aRange) < 0.001d) && (abs(dRange) < 0.001d)) {      isAtEmotionCenter = true;    }    return isAtEmotionCenter;  }  private boolean isMoodInEmotionsCenterSubCube(Mood currentMood) {    boolean isInEmotionsCenterSubCube = false;    if ((((fEmotionsCenter.getPValue() >= 0.0d) &&            (currentMood.getPleasure() >= fEmotionsCenter.getPValue())) ||            ((fEmotionsCenter.getPValue() < 0.0d) &&            (currentMood.getPleasure() <= fEmotionsCenter.getPValue()))) &&            (((fEmotionsCenter.getAValue() >= 0.0d) &&            (currentMood.getArousal() >= fEmotionsCenter.getAValue())) ||            ((fEmotionsCenter.getAValue() < 0.0d) &&            (currentMood.getArousal() <= fEmotionsCenter.getAValue()))) &&            (((fEmotionsCenter.getDValue() >= 0.0d) &&            (currentMood.getDominance() >= fEmotionsCenter.getDValue())) ||            ((fEmotionsCenter.getDValue() < 0.0d) &&            (currentMood.getDominance() <= fEmotionsCenter.getDValue())))) {      isInEmotionsCenterSubCube = true;    }    return isInEmotionsCenterSubCube;  }  public synchronized Mood getCurrentMoodTendency() {    return (fCurrentMoodTendency != null) ? fCurrentMoodTendency : fDefaultMood;  }  /**   * <code>compute</code> computes the new current mood based on the actual   * current mood and the active emotion(s) of a character.   *   * @param currentMood the current mood that will be checked if it is at the    *                    emotion(s) center position.   * @param emotions the active emotion(s) of a character   *   * @return Mood the new current mood   */  public synchronized Mood compute(Mood currentMood, EmotionVector emotions) {    // increment mood return counter to 0    fOverallMoodReturnCnt++;    fEmotionsCenter.clear();    for (Iterator<Emotion> it = emotions.getEmotions().iterator(); it.hasNext();) {      Emotion emotion = it.next();      EmotionType eType = emotion.getType();      double eIntensity = emotion.getIntensity();      if (eIntensity > emotion.getBaseline()) {        // log.info("Active emotion " + eType + " influences current mood");        Mood ePAD = (eType.equals(EmotionType.Physical)) ? emotion.getPADValues() : getEmotionPADMapping(eType);        //log.info(eType + " PAD representation is (" + ePAD.getPleasure() + ", " +  ePAD.getArousal() + " , " + ePAD.getDominance() + ")");        fEmotionsCenter.add(ePAD.getPleasure(), ePAD.getArousal(), ePAD.getDominance(), eIntensity);      //log.info(fEmotionsCenter.toString());      }    }    if (fEmotionsCenter.isActive()) {      // reset mood return counter to 0      fOverallMoodReturnCnt = 0;      double emotionImpact = fEmotionsCenter.getWeight();      //log.info(fPersonality + " Emotion(s) impact is " + prettyPrint(emotionImpact));      if (isMoodAtEmotionsCenter(currentMood)) {        //log.info(fPersonality + " Current mood " + currentMood + " is at emotion(s) center");        currentMood = new Mood(fEmotionsCenter.getPValue(), fEmotionsCenter.getAValue(),                fEmotionsCenter.getDValue());      }      if (isMoodInEmotionsCenterSubCube(currentMood)) {        //log.info(fPersonality + " Moving mood deeper in emotion(s) center sub cube");        Mood planePoint = getPADPlanePoint(fEmotionsCenter, new Mood(0.0d, 0.0d, 0.0d));        currentMood = (planePoint != null) ? moveMoodLinear(currentMood, emotionImpact,                planePoint.getPleasure(),                planePoint.getArousal(),                planePoint.getDominance()) : currentMood;      } else {        Mood planePoint = getPADPlanePoint(fEmotionsCenter, currentMood);        //log.info(fPersonality + " Using intersection point (" + prettyPrint(planePoint.getPleasure()) + ", " +  prettyPrint(planePoint.getArousal()) + ", " +  prettyPrint(planePoint.getDominance()) + ")");        currentMood = (planePoint != null) ? moveMoodLinear(currentMood, emotionImpact,                planePoint.getPleasure(),                planePoint.getArousal(),                planePoint.getDominance()) : currentMood;      }    //Mood planePoint = getPADPlanePoint(fEmotionsCenter, currentMood);    } else {      if (currentMood != fDefaultMood) {        double pMoodToDefMood = (fDefaultMood.getPleasure() - currentMood.getPleasure());        double aMoodToDefMood = (fDefaultMood.getArousal() - currentMood.getArousal());        double dMoodToDefMood = (fDefaultMood.getDominance() - currentMood.getDominance());        // if current mood is very close to default mood, stop the move back process        if ((abs(pMoodToDefMood) < 0.006d) && (abs(aMoodToDefMood) < 0.006d) &&                (abs(dMoodToDefMood) < 0.006d)) {          currentMood = fDefaultMood;        } else {          //debug log.info ("Current mood drifting back to default mood");          //debug log.info (currentMood + " -> " + fDefaultMood);          currentMood = moveMoodLinear(currentMood, sDEFAULTMOODIMPACT,                  pMoodToDefMood, aMoodToDefMood, dMoodToDefMood);          if (fNeurotismMoodChanges) {            currentMood = randomMoodChange(currentMood, 0.005d,                    pMoodToDefMood, aMoodToDefMood, dMoodToDefMood);          }        }      } else {        // move mood away from default mood, ...        if (fNeurotismMoodChanges) {          //debug log.info("Crazy mood change");          currentMood = randomMoodChange(currentMood, 0.05d, //initial "jump" from default mood                  random() * 2.0d - 1.0d, random() * 2.0d - 1.0d, random() * 2.0d - 1.0d);        }      }    }    return currentMood;  }}