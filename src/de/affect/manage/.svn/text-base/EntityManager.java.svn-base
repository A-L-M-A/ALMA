/* * EntityManager.java * * Copyright (c) 2005 by Patrick Gebhard * All rights reserved. * */package de.affect.manage;import java.util.List;import java.util.ArrayList;import static java.lang.Math.abs;import static java.lang.Math.pow;import static java.lang.Math.sqrt;import de.affect.appraisal.AppraisalVariables;import de.affect.emotion.EmotionVector;import de.affect.mood.Mood;import de.affect.personality.Personality;import de.affect.data.AffectConsts;import de.affect.emotion.EmotionType;import java.util.logging.Logger;import static de.affect.personality.PersonalityMoodRelations.getDefaultMood;/**  * The class <code>EntityManager</code> initially stores name and * appraisal rules of an abstract entity. * It also provides placeholders for basic affective structure such as  * personality, mood, emotions, these must be inspirit by higher-level entities * (e.g. by the <code>CharacterManager</code> or <code>GroupManager</code>) * * @author Patrick Gebhard * * @version 1.0 */class EntityManager {  String fName = null;  AppraisalRules fAppraisalRules = null;  Personality fPersonality = null;  Mood fDefaultMood = null;  Mood fCurrentMood = null;  Mood fCurrentMoodTendency = null;  EmotionVector fEmotionVector = null;  List<EmotionType> fAvailEmotions = null;  AffectConsts fAc = null;  private Logger log = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);;  public EntityManager(String name) {    fName = name;    //Initialise the affect placeholders with default values    fPersonality = new Personality(0.0d, 0.0d, 0.0d, 0.0d, 0.0d);    fDefaultMood = getDefaultMood(fPersonality);    fCurrentMood = getDefaultMood(fPersonality);    fCurrentMoodTendency = getDefaultMood(fPersonality);    fAvailEmotions = new ArrayList<EmotionType>();    fAvailEmotions.add(EmotionType.Undefined);    // PG: added a new common type of emotions that are derived by bio sensors    fAvailEmotions.add(EmotionType.Physical);    fEmotionVector = createEmotionVector();    fAc = new AffectConsts();  }  /**   * <code>getName</code> returns the name of this entity    *   * @return String contains the name of this entity   */  public String getName() {    return fName;  }  /**   * <code>setAppraisalRules</code> set the appraisalRules for this entity.   *   * @param rules a new AppraisalRules   */  public synchronized void setAppraisalRules(AppraisalRules rules) {    fAppraisalRules = rules;  }  /**   * <code>getAppraisalRules</code> returns all appraisalRules for this entity.   *   * @return AppraisalRules contains the actual entitie's appraisal rules   */  public synchronized AppraisalRules getAppraisalRules() {     return fAppraisalRules;  }  /**   * <code>getAppraisalRules</code> returns appraisalRules of the given type   * for this entity.   *   * @param type type of appraisal variables   *   * @return AppraisalRules contains the actual entitie's appraisal rules   */  public synchronized AppraisalRules getAppraisalRules(String type) {     return fAppraisalRules.getAppraisalRulesByType(fName, type);  }  /**   * <code>getAppraisalRuleKeys</code> returns appraisal rule keys of the given   * type for this entity.   *   * @param type type of appraisal variables   *   * @return AppraisalRules contains the actual entitie's appraisal rules   */  public synchronized String[] getAppraisalRuleKeys(String type) {     return fAppraisalRules.getAppraisalRulesByType(fName, type).getKeys(fName);  }  /**   * <code>getAppraisalVariables</code> returns AppraisalVariables for a given    * key.   *   * @param key the rule key that is related to a signal of the world    *   * @return AppraisalVariables[] contains the appraisal variables related to   *                               a key and this entity   */  public synchronized AppraisalVariables[] getAppraisalVariables(String key) {    AppraisalVariables[] appVars = fAppraisalRules.getAppraisalVariables(fName, key);    appVars = (appVars == null) ? new AppraisalVariables[0] : appVars;    return appVars;  }  /**   * <code>getAppraisalVariables</code> returns AppraisalVariables for a given    * key.   *   * @param key the rule key that is related to a signal of the world    * @param type type of appraisal variables   *   * @return AppraisalVariables[] contains the appraisal variables related to   *                               a key and this entity   */  public synchronized AppraisalVariables[] getAppraisalVariables(String key, String type) {    AppraisalVariables[] appVars =       fAppraisalRules.getAppraisalRulesByType(fName, type).getAppraisalVariables(fName, key);    appVars = (appVars == null) ? new AppraisalVariables[0] : appVars;    return appVars;  }  /**   * <code>getAppraisalVariables</code> returns AppraisalVariables for a given    * key.   *   * @param entity another entity that is related to that key   * @param key the rule key that is related to a signal of the world    *   * @return AppraisalVariables[] contains the appraisal variables related to   *                               a key and entity   */  public synchronized AppraisalVariables[] getAppraisalVariables(EntityManager entity, String key) {    AppraisalVariables[] appVars = fAppraisalRules.getAppraisalVariables(entity.getName(), key);    appVars = (appVars == null) ? new AppraisalVariables[0] : appVars;    return appVars;  }  /**   * <code>getAppraisalVariables</code> returns AppraisalVariables for a given    * key.   *   * @param entity another entity that is related to that key   * @param key the rule key that is related to a signal of the world    * @param type type of appraisal variables   *   * @return AppraisalVariables[] contains the appraisal variables related to   *                               a key and entity   */  public synchronized AppraisalVariables[] getAppraisalVariables(EntityManager entity, String key, String type) {    AppraisalVariables[] appVars =       fAppraisalRules.getAppraisalRulesByType(entity.getName(), type).getAppraisalVariables(entity.getName(), key);    appVars = (appVars == null) ? new AppraisalVariables[0] : appVars;    return appVars;  }  /**   * <code>getAppraisalVariables</code> returns all keys related to signals   *   * @param entity the entity that is related to that key   *   * @return String[] contains all keys related to the entity   */  public synchronized String[] getAppraisalRuleKeys(EntityManager entity) {    return fAppraisalRules.getKeys(entity.getName());  }  /**   * Gets the personality of this entity    *   * @return the entity current personality   */  public synchronized Personality getPersonality() {    return fPersonality;  }    public synchronized Mood getCurrentMood() {    return fCurrentMood;  }  public synchronized Mood defaultMood() {    return fDefaultMood;  }  public synchronized Mood getCurrentMoodTendency() {    return fCurrentMood;  }  public synchronized double getDistancetoDefaultMood() {    double cPleasure = fCurrentMood.getPleasure();    double cArousal = fCurrentMood.getArousal();    double cDominance = fCurrentMood.getDominance();    double dPleasure = fDefaultMood.getPleasure();    double dArousal = fDefaultMood.getArousal();    double dDominance = fDefaultMood.getDominance();    return      sqrt(pow(abs(cPleasure - dPleasure), 2.0d) + 	   pow(abs(cArousal - dArousal), 2.0d) + 	   pow(abs(cDominance - dDominance), 2.0d));   }  public synchronized EmotionVector getCurrentEmotions() {    //log.info("Get current Emotions " + fEmotionVector.toString());    return fEmotionVector;  }  public synchronized AffectConsts getAffectConsts() {    return fAc;  }  public synchronized EmotionVector createEmotionVector() {    return new EmotionVector(fPersonality, fCurrentMood, fAvailEmotions);  }}