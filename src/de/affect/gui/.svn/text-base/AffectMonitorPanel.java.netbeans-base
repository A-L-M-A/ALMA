/* * AffectMonitorPanel.java * * Copyright (c) 2004 by Patrick Gebhard * All rights reserved. * */package de.affect.gui;import java.util.*;import java.awt.*;import javax.swing.*;import java.util.logging.Logger;import javax.swing.border.Border;import static javax.swing.BorderFactory.createEmptyBorder;import static javax.swing.BorderFactory.createLineBorder;import static javax.swing.BorderFactory.createCompoundBorder;import static javax.swing.BorderFactory.createTitledBorder;import de.affect.emotion.Emotion;import de.affect.mood.Mood;import de.affect.emotion.EmotionVector;import de.affect.emotion.EmotionType;import de.affect.emotion.EmotionPADCentroid;import static de.affect.emotion.EmotionsPADRelation.getEmotionPADMapping;import static de.affect.gui.AlmaGUI.sDefaultTitleFont;import static de.affect.gui.AlmaGUI.sBORDERLINE;/** * The <code>AffectMonitorPanel</code> displays all characters' affective status. * Information are given about the current mood and emotions respectively its  * actual intensity.  *  * @author Patrick Gebhard * * @version 2.0 */public class AffectMonitorPanel extends JPanel {  private Hashtable<String, EmotionVectorPanel> characterToEmotionPanel =          new Hashtable<String, EmotionVectorPanel>();  private Hashtable<String, Mood3D> characterToMoodDisplay =          new Hashtable<String, Mood3D>();  private Hashtable<String, AffectStatusPanel> characterToStatusPanel =          new Hashtable<String, AffectStatusPanel>();  private Hashtable<String, Boolean> characterToClearStatus =          new Hashtable<String, Boolean>();  private Hashtable<EmotionType, Double> EmotionTypesToIntensities =          new Hashtable<EmotionType, Double>();  private JPanel characterPanel = null;  private boolean fIsReady = false;  private Logger log = Logger.global;  public AffectMonitorPanel(EmotionMaintainerNotifier affectMonitor,          String character, EmotionVector vec, Mood currentMood) {    setLayout(new BoxLayout(this, BoxLayout.X_AXIS));    setDoubleBuffered(true);    characterPanel = new JPanel();    characterPanel.setLayout(new BoxLayout(characterPanel, BoxLayout.X_AXIS));    JPanel affectPanel = new JPanel();    affectPanel.setLayout(new BoxLayout(affectPanel, BoxLayout.X_AXIS));    EmotionVectorPanel emotionPanel = new EmotionVectorPanel(affectMonitor, character, vec);    emotionPanel.setLayout(new BoxLayout(emotionPanel, BoxLayout.Y_AXIS));    affectPanel.add(emotionPanel);    JPanel moodAndStatusPanel = new JPanel();    moodAndStatusPanel.setLayout(new BoxLayout(moodAndStatusPanel, BoxLayout.Y_AXIS));    JPanel moodCubePanel = new JPanel();    moodCubePanel.setLayout(new BoxLayout(moodCubePanel, BoxLayout.X_AXIS));    Border border =            createCompoundBorder(createTitledBorder(createLineBorder(sBORDERLINE),            " Mood cube ", 0, 0, sDefaultTitleFont),            createEmptyBorder(1, 1, 1, 1));    moodCubePanel.setBorder(border);    Mood3D moodDisplay = new Mood3D(0.0, 0.125, -4.0, -35.0, false, 64000);    moodCubePanel.add(BorderLayout.CENTER, moodDisplay);    characterToMoodDisplay.put(character, moodDisplay);    String currentMoodString =            currentMood.getMoodWordIntensity() + " " + currentMood.getMoodWord();    AffectStatusPanel statusPanel =            new AffectStatusPanel(vec.getDominantEmotion().getType().toString(),            currentMoodString, currentMoodString, currentMoodString);    statusPanel.setLayout(new BoxLayout(statusPanel, BoxLayout.Y_AXIS));    moodAndStatusPanel.add(moodCubePanel);    moodAndStatusPanel.add(statusPanel);    affectPanel.add(moodAndStatusPanel);    characterPanel.add(affectPanel);    add(characterPanel);    characterToEmotionPanel.put(character, emotionPanel);    characterToStatusPanel.put(character, statusPanel);    for (Iterator<Emotion> it = vec.getEmotions().iterator(); it.hasNext();) {      Emotion emotion = it.next();      EmotionType eType = emotion.getType();      EmotionTypesToIntensities.put(eType, new Double(emotion.getIntensity()));    }    characterToClearStatus.put(character, new Boolean(true));    fIsReady = true;  }  public void updateEmotionDisplay(String character, EmotionVector vec) {    if (fIsReady) {      EmotionVectorPanel panel =              (EmotionVectorPanel) characterToEmotionPanel.get(character);      if (panel != null) {        panel.updateVector(vec);      }    }  }  public void updateMoodDisplay(String character, EmotionVector emotions,          EmotionPADCentroid emotionCenter,          Mood defaultMood, Mood currentMood, Mood currentMoodTendency) {    if (fIsReady) {      String currentMoodString =              currentMood.toString();      //currentMood.getMoodWordIntensity() + " " + currentMood.getMoodWord();      String currentMoodTendencyString =              currentMoodTendency.getMoodWordIntensity() + " " + currentMoodTendency.getMoodWord();      String defaultMoodString =              defaultMood.getMoodWordIntensity() + " " + defaultMood.getMoodWord();      Boolean clearStatus = characterToClearStatus.get(character);      boolean cleared3DEmotionDisplay = true;      if (clearStatus != null) {        cleared3DEmotionDisplay = clearStatus.booleanValue();      }      AffectStatusPanel panel = characterToStatusPanel.get(character);      if (panel != null) {        panel.updateStatus(emotions.getDominantEmotion().getType(),                defaultMoodString, currentMoodString,                currentMoodTendencyString);      }      Mood3D moodDisplay = characterToMoodDisplay.get(character);      if (moodDisplay != null) {        moodDisplay.updateMood(currentMood.getPleasure(),                currentMood.getArousal(),                currentMood.getDominance(), 1.0d);        int emoCnt = 0;        if (!(emotions.getDominantEmotion().getType() == EmotionType.Undefined)) {          for (Iterator<Emotion> it = emotions.getEmotions().iterator(); it.hasNext();) {            Emotion emotion = it.next();            EmotionType eType = emotion.getType();            double currentIntensity = emotion.getIntensity();            double baseline = emotion.getBaseline();            double lastIntensity = EmotionTypesToIntensities.get(eType).doubleValue();            if (currentIntensity > baseline) {              //Logger.global.info(character + " drawing emotion " + eType.toString());              Mood ePAD = (eType.equals(EmotionType.Physical)) ? emotion.getPADValues() : getEmotionPADMapping(eType);              moodDisplay.updateEmotion(eType.toString(),                      ePAD.getPleasure(),                      ePAD.getArousal(),                      ePAD.getDominance(),                      emotion.getIntensity());              emoCnt++;            }            if (((currentIntensity - 0.0004) < baseline) &&                    (lastIntensity > currentIntensity)) {              moodDisplay.hideEmotion(eType.toString());            //Logger.global.info("removing " + eType);            }            EmotionTypesToIntensities.put(eType, new Double(currentIntensity));                        cleared3DEmotionDisplay = false;            characterToClearStatus.put(character, new Boolean(cleared3DEmotionDisplay));          }        } else {          if (!cleared3DEmotionDisplay) {            //Logger.global.info(character + " clearing emotions");            for (Iterator<Emotion> it = emotions.getEmotions().iterator(); it.hasNext();) {              moodDisplay.hideEmotion(it.next().getType().toString());            }            cleared3DEmotionDisplay = true;            characterToClearStatus.put(character, new Boolean(cleared3DEmotionDisplay));          }        }        if (emoCnt > 1) {          //Logger.global.info(emotionCenter.toString());                    moodDisplay.updateEmotionCenter(emotionCenter.getPValue(),                  emotionCenter.getAValue(),                  emotionCenter.getDValue(),                  emotionCenter.getWeight());        } else {          moodDisplay.hideEmotionCenter();        }      }    }  }}